// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package ingest

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type WalEntryT struct {
	EventId []byte `json:"event_id"`
	EventType string `json:"event_type"`
	OccurredAt uint64 `json:"occurred_at"`
	IngestedAt uint64 `json:"ingested_at"`
	Payload []byte `json:"payload"`
	Compression CompressionType `json:"compression"`
	SchemaId uint32 `json:"schema_id"`
	Metadata []*KeyValueT `json:"metadata"`
}

func (t *WalEntryT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	eventIdOffset := flatbuffers.UOffsetT(0)
	if t.EventId != nil {
		eventIdOffset = builder.CreateByteString(t.EventId)
	}
	eventTypeOffset := flatbuffers.UOffsetT(0)
	if t.EventType != "" {
		eventTypeOffset = builder.CreateString(t.EventType)
	}
	payloadOffset := flatbuffers.UOffsetT(0)
	if t.Payload != nil {
		payloadOffset = builder.CreateByteString(t.Payload)
	}
	metadataOffset := flatbuffers.UOffsetT(0)
	if t.Metadata != nil {
		metadataLength := len(t.Metadata)
		metadataOffsets := make([]flatbuffers.UOffsetT, metadataLength)
		for j := 0; j < metadataLength; j++ {
			metadataOffsets[j] = t.Metadata[j].Pack(builder)
		}
		WalEntryStartMetadataVector(builder, metadataLength)
		for j := metadataLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(metadataOffsets[j])
		}
		metadataOffset = builder.EndVector(metadataLength)
	}
	WalEntryStart(builder)
	WalEntryAddEventId(builder, eventIdOffset)
	WalEntryAddEventType(builder, eventTypeOffset)
	WalEntryAddOccurredAt(builder, t.OccurredAt)
	WalEntryAddIngestedAt(builder, t.IngestedAt)
	WalEntryAddPayload(builder, payloadOffset)
	WalEntryAddCompression(builder, t.Compression)
	WalEntryAddSchemaId(builder, t.SchemaId)
	WalEntryAddMetadata(builder, metadataOffset)
	return WalEntryEnd(builder)
}

func (rcv *WalEntry) UnPackTo(t *WalEntryT) {
	t.EventId = rcv.EventIdBytes()
	t.EventType = string(rcv.EventType())
	t.OccurredAt = rcv.OccurredAt()
	t.IngestedAt = rcv.IngestedAt()
	t.Payload = rcv.PayloadBytes()
	t.Compression = rcv.Compression()
	t.SchemaId = rcv.SchemaId()
	metadataLength := rcv.MetadataLength()
	t.Metadata = make([]*KeyValueT, metadataLength)
	for j := 0; j < metadataLength; j++ {
		x := KeyValue{}
		rcv.Metadata(&x, j)
		t.Metadata[j] = x.UnPack()
	}
}

func (rcv *WalEntry) UnPack() *WalEntryT {
	if rcv == nil {
		return nil
	}
	t := &WalEntryT{}
	rcv.UnPackTo(t)
	return t
}

type WalEntry struct {
	_tab flatbuffers.Table
}

func GetRootAsWalEntry(buf []byte, offset flatbuffers.UOffsetT) *WalEntry {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &WalEntry{}
	x.Init(buf, n+offset)
	return x
}

func FinishWalEntryBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.Finish(offset)
}

func GetSizePrefixedRootAsWalEntry(buf []byte, offset flatbuffers.UOffsetT) *WalEntry {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &WalEntry{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func FinishSizePrefixedWalEntryBuffer(builder *flatbuffers.Builder, offset flatbuffers.UOffsetT) {
	builder.FinishSizePrefixed(offset)
}

func (rcv *WalEntry) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *WalEntry) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *WalEntry) EventId(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *WalEntry) EventIdLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WalEntry) EventIdBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *WalEntry) MutateEventId(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *WalEntry) EventType() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *WalEntry) OccurredAt() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *WalEntry) MutateOccurredAt(n uint64) bool {
	return rcv._tab.MutateUint64Slot(8, n)
}

func (rcv *WalEntry) IngestedAt() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *WalEntry) MutateIngestedAt(n uint64) bool {
	return rcv._tab.MutateUint64Slot(10, n)
}

func (rcv *WalEntry) Payload(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *WalEntry) PayloadLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *WalEntry) PayloadBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *WalEntry) MutatePayload(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *WalEntry) Compression() CompressionType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return CompressionType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *WalEntry) MutateCompression(n CompressionType) bool {
	return rcv._tab.MutateInt8Slot(14, int8(n))
}

func (rcv *WalEntry) SchemaId() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *WalEntry) MutateSchemaId(n uint32) bool {
	return rcv._tab.MutateUint32Slot(16, n)
}

func (rcv *WalEntry) Metadata(obj *KeyValue, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *WalEntry) MetadataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func WalEntryStart(builder *flatbuffers.Builder) {
	builder.StartObject(8)
}
func WalEntryAddEventId(builder *flatbuffers.Builder, eventId flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(eventId), 0)
}
func WalEntryStartEventIdVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func WalEntryAddEventType(builder *flatbuffers.Builder, eventType flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(eventType), 0)
}
func WalEntryAddOccurredAt(builder *flatbuffers.Builder, occurredAt uint64) {
	builder.PrependUint64Slot(2, occurredAt, 0)
}
func WalEntryAddIngestedAt(builder *flatbuffers.Builder, ingestedAt uint64) {
	builder.PrependUint64Slot(3, ingestedAt, 0)
}
func WalEntryAddPayload(builder *flatbuffers.Builder, payload flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(payload), 0)
}
func WalEntryStartPayloadVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func WalEntryAddCompression(builder *flatbuffers.Builder, compression CompressionType) {
	builder.PrependInt8Slot(5, int8(compression), 0)
}
func WalEntryAddSchemaId(builder *flatbuffers.Builder, schemaId uint32) {
	builder.PrependUint32Slot(6, schemaId, 0)
}
func WalEntryAddMetadata(builder *flatbuffers.Builder, metadata flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(metadata), 0)
}
func WalEntryStartMetadataVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func WalEntryEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
