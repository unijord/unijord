// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: ingest/v1/ingest.proto

package ingestv1

import (
	_ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// CompressionType for event payloads.
type CompressionType int32

const (
	CompressionType_COMPRESSION_TYPE_UNSPECIFIED CompressionType = 0
	CompressionType_COMPRESSION_TYPE_NONE        CompressionType = 1
	CompressionType_COMPRESSION_TYPE_SNAPPY      CompressionType = 2
	CompressionType_COMPRESSION_TYPE_ZSTD        CompressionType = 3
)

// Enum value maps for CompressionType.
var (
	CompressionType_name = map[int32]string{
		0: "COMPRESSION_TYPE_UNSPECIFIED",
		1: "COMPRESSION_TYPE_NONE",
		2: "COMPRESSION_TYPE_SNAPPY",
		3: "COMPRESSION_TYPE_ZSTD",
	}
	CompressionType_value = map[string]int32{
		"COMPRESSION_TYPE_UNSPECIFIED": 0,
		"COMPRESSION_TYPE_NONE":        1,
		"COMPRESSION_TYPE_SNAPPY":      2,
		"COMPRESSION_TYPE_ZSTD":        3,
	}
)

func (x CompressionType) Enum() *CompressionType {
	p := new(CompressionType)
	*p = x
	return p
}

func (x CompressionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CompressionType) Descriptor() protoreflect.EnumDescriptor {
	return file_ingest_v1_ingest_proto_enumTypes[0].Descriptor()
}

func (CompressionType) Type() protoreflect.EnumType {
	return &file_ingest_v1_ingest_proto_enumTypes[0]
}

func (x CompressionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CompressionType.Descriptor instead.
func (CompressionType) EnumDescriptor() ([]byte, []int) {
	return file_ingest_v1_ingest_proto_rawDescGZIP(), []int{0}
}

// ErrorCode categorizes append failures.
type ErrorCode int32

const (
	ErrorCode_ERROR_CODE_UNSPECIFIED       ErrorCode = 0
	ErrorCode_ERROR_CODE_OK                ErrorCode = 1
	ErrorCode_ERROR_CODE_INVALID_REQUEST   ErrorCode = 2
	ErrorCode_ERROR_CODE_INVALID_NAMESPACE ErrorCode = 3
	ErrorCode_ERROR_CODE_INVALID_TOPIC     ErrorCode = 4
	ErrorCode_ERROR_CODE_INVALID_EVENT     ErrorCode = 5
	ErrorCode_ERROR_CODE_PAYLOAD_TOO_LARGE ErrorCode = 6
	ErrorCode_ERROR_CODE_RATE_LIMITED      ErrorCode = 7
	ErrorCode_ERROR_CODE_NOT_LEADER        ErrorCode = 8
	ErrorCode_ERROR_CODE_NO_QUORUM         ErrorCode = 9
	ErrorCode_ERROR_CODE_TIMEOUT           ErrorCode = 10
	ErrorCode_ERROR_CODE_SCHEMA_NOT_FOUND  ErrorCode = 11
	ErrorCode_ERROR_CODE_INTERNAL          ErrorCode = 99
)

// Enum value maps for ErrorCode.
var (
	ErrorCode_name = map[int32]string{
		0:  "ERROR_CODE_UNSPECIFIED",
		1:  "ERROR_CODE_OK",
		2:  "ERROR_CODE_INVALID_REQUEST",
		3:  "ERROR_CODE_INVALID_NAMESPACE",
		4:  "ERROR_CODE_INVALID_TOPIC",
		5:  "ERROR_CODE_INVALID_EVENT",
		6:  "ERROR_CODE_PAYLOAD_TOO_LARGE",
		7:  "ERROR_CODE_RATE_LIMITED",
		8:  "ERROR_CODE_NOT_LEADER",
		9:  "ERROR_CODE_NO_QUORUM",
		10: "ERROR_CODE_TIMEOUT",
		11: "ERROR_CODE_SCHEMA_NOT_FOUND",
		99: "ERROR_CODE_INTERNAL",
	}
	ErrorCode_value = map[string]int32{
		"ERROR_CODE_UNSPECIFIED":       0,
		"ERROR_CODE_OK":                1,
		"ERROR_CODE_INVALID_REQUEST":   2,
		"ERROR_CODE_INVALID_NAMESPACE": 3,
		"ERROR_CODE_INVALID_TOPIC":     4,
		"ERROR_CODE_INVALID_EVENT":     5,
		"ERROR_CODE_PAYLOAD_TOO_LARGE": 6,
		"ERROR_CODE_RATE_LIMITED":      7,
		"ERROR_CODE_NOT_LEADER":        8,
		"ERROR_CODE_NO_QUORUM":         9,
		"ERROR_CODE_TIMEOUT":           10,
		"ERROR_CODE_SCHEMA_NOT_FOUND":  11,
		"ERROR_CODE_INTERNAL":          99,
	}
)

func (x ErrorCode) Enum() *ErrorCode {
	p := new(ErrorCode)
	*p = x
	return p
}

func (x ErrorCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ErrorCode) Descriptor() protoreflect.EnumDescriptor {
	return file_ingest_v1_ingest_proto_enumTypes[1].Descriptor()
}

func (ErrorCode) Type() protoreflect.EnumType {
	return &file_ingest_v1_ingest_proto_enumTypes[1]
}

func (x ErrorCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ErrorCode.Descriptor instead.
func (ErrorCode) EnumDescriptor() ([]byte, []int) {
	return file_ingest_v1_ingest_proto_rawDescGZIP(), []int{1}
}

type HealthStatus int32

const (
	HealthStatus_HEALTH_STATUS_UNSPECIFIED HealthStatus = 0
	HealthStatus_HEALTH_STATUS_HEALTHY     HealthStatus = 1
	HealthStatus_HEALTH_STATUS_DEGRADED    HealthStatus = 2
	HealthStatus_HEALTH_STATUS_UNHEALTHY   HealthStatus = 3
)

// Enum value maps for HealthStatus.
var (
	HealthStatus_name = map[int32]string{
		0: "HEALTH_STATUS_UNSPECIFIED",
		1: "HEALTH_STATUS_HEALTHY",
		2: "HEALTH_STATUS_DEGRADED",
		3: "HEALTH_STATUS_UNHEALTHY",
	}
	HealthStatus_value = map[string]int32{
		"HEALTH_STATUS_UNSPECIFIED": 0,
		"HEALTH_STATUS_HEALTHY":     1,
		"HEALTH_STATUS_DEGRADED":    2,
		"HEALTH_STATUS_UNHEALTHY":   3,
	}
)

func (x HealthStatus) Enum() *HealthStatus {
	p := new(HealthStatus)
	*p = x
	return p
}

func (x HealthStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HealthStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_ingest_v1_ingest_proto_enumTypes[2].Descriptor()
}

func (HealthStatus) Type() protoreflect.EnumType {
	return &file_ingest_v1_ingest_proto_enumTypes[2]
}

func (x HealthStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HealthStatus.Descriptor instead.
func (HealthStatus) EnumDescriptor() ([]byte, []int) {
	return file_ingest_v1_ingest_proto_rawDescGZIP(), []int{2}
}

// KeyValue for event metadata.
type KeyValue struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         []byte                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyValue) Reset() {
	*x = KeyValue{}
	mi := &file_ingest_v1_ingest_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyValue) ProtoMessage() {}

func (x *KeyValue) ProtoReflect() protoreflect.Message {
	mi := &file_ingest_v1_ingest_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyValue.ProtoReflect.Descriptor instead.
func (*KeyValue) Descriptor() ([]byte, []int) {
	return file_ingest_v1_ingest_proto_rawDescGZIP(), []int{0}
}

func (x *KeyValue) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *KeyValue) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

// Event represents a single event to ingest.
type Event struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Client-provided UUID (16 bytes).
	EventId []byte `protobuf:"bytes,1,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
	// Event type for self-describing data (e.g., "order.created", "user.signup").
	EventType string `protobuf:"bytes,2,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// When the event occurred (microseconds since Unix epoch).
	// If 0, server will use current time.
	OccurredAt uint64 `protobuf:"varint,3,opt,name=occurred_at,json=occurredAt,proto3" json:"occurred_at,omitempty"`
	// Event payload (Avro, JSON, Protobuf - opaque to Unijord).
	// Currently only Avro is supported for schema registry integration.
	Payload []byte `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	// Compression applied to payload.
	Compression CompressionType `protobuf:"varint,5,opt,name=compression,proto3,enum=ingest.v1.CompressionType" json:"compression,omitempty"`
	// Schema registry ID for payload deserialization.
	SchemaId uint32 `protobuf:"varint,6,opt,name=schema_id,json=schemaId,proto3" json:"schema_id,omitempty"`
	// Used by server to derive storage partition paths when topic config references metadata.{key}.
	Metadata      []*KeyValue `protobuf:"bytes,7,rep,name=metadata,proto3" json:"metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Event) Reset() {
	*x = Event{}
	mi := &file_ingest_v1_ingest_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Event) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Event) ProtoMessage() {}

func (x *Event) ProtoReflect() protoreflect.Message {
	mi := &file_ingest_v1_ingest_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Event.ProtoReflect.Descriptor instead.
func (*Event) Descriptor() ([]byte, []int) {
	return file_ingest_v1_ingest_proto_rawDescGZIP(), []int{1}
}

func (x *Event) GetEventId() []byte {
	if x != nil {
		return x.EventId
	}
	return nil
}

func (x *Event) GetEventType() string {
	if x != nil {
		return x.EventType
	}
	return ""
}

func (x *Event) GetOccurredAt() uint64 {
	if x != nil {
		return x.OccurredAt
	}
	return 0
}

func (x *Event) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *Event) GetCompression() CompressionType {
	if x != nil {
		return x.Compression
	}
	return CompressionType_COMPRESSION_TYPE_UNSPECIFIED
}

func (x *Event) GetSchemaId() uint32 {
	if x != nil {
		return x.SchemaId
	}
	return 0
}

func (x *Event) GetMetadata() []*KeyValue {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// AppendRequest contains a batch of events to ingest.
//
// Routing is handled via headers:
//   - x-namespace: Tenant isolation (from header or server config)
//   - x-topic: Stream/topic name (from header)
//   - x-routing-key: For Envoy consistent hash routing to shards
type AppendRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Events to ingest (max 1000 per batch).
	Events []*Event `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	// Request timeout hint (milliseconds). Server may use for backpressure.
	TimeoutMs uint32 `protobuf:"varint,2,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms,omitempty"`
	// Routing key for shard affinity.
	// Events with the same routing_key go to the same shard (via Envoy ring hash).
	// Also exposed as x-routing-key header for Envoy-based routing.
	// If empty, requests are distributed round-robin across shards.
	RoutingKey    string `protobuf:"bytes,3,opt,name=routing_key,json=routingKey,proto3" json:"routing_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppendRequest) Reset() {
	*x = AppendRequest{}
	mi := &file_ingest_v1_ingest_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppendRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppendRequest) ProtoMessage() {}

func (x *AppendRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ingest_v1_ingest_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppendRequest.ProtoReflect.Descriptor instead.
func (*AppendRequest) Descriptor() ([]byte, []int) {
	return file_ingest_v1_ingest_proto_rawDescGZIP(), []int{2}
}

func (x *AppendRequest) GetEvents() []*Event {
	if x != nil {
		return x.Events
	}
	return nil
}

func (x *AppendRequest) GetTimeoutMs() uint32 {
	if x != nil {
		return x.TimeoutMs
	}
	return 0
}

func (x *AppendRequest) GetRoutingKey() string {
	if x != nil {
		return x.RoutingKey
	}
	return ""
}

// AppendResponse contains the result of an append operation.
type AppendResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Whether the append succeeded.
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// Error code if failed.
	ErrorCode ErrorCode `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3,enum=ingest.v1.ErrorCode" json:"error_code,omitempty"`
	// Human-readable error message.
	ErrorMessage string `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// LSN (Log Sequence Number) of the last committed event.
	// All events in the batch are assigned sequential LSNs ending with this.
	CommittedLsn uint64 `protobuf:"varint,4,opt,name=committed_lsn,json=committedLsn,proto3" json:"committed_lsn,omitempty"`
	// Number of events successfully ingested.
	IngestedCount uint32 `protobuf:"varint,5,opt,name=ingested_count,json=ingestedCount,proto3" json:"ingested_count,omitempty"`
	// Backpressure: client should wait this many ms before retrying.
	RetryAfterMs uint32 `protobuf:"varint,6,opt,name=retry_after_ms,json=retryAfterMs,proto3" json:"retry_after_ms,omitempty"`
	// Current load percentage (0-100) for client flow control.
	CurrentLoadPct uint32 `protobuf:"varint,7,opt,name=current_load_pct,json=currentLoadPct,proto3" json:"current_load_pct,omitempty"`
	// Leader address if this node is not the leader (for client redirect).
	LeaderAddress string `protobuf:"bytes,8,opt,name=leader_address,json=leaderAddress,proto3" json:"leader_address,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AppendResponse) Reset() {
	*x = AppendResponse{}
	mi := &file_ingest_v1_ingest_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AppendResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AppendResponse) ProtoMessage() {}

func (x *AppendResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ingest_v1_ingest_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AppendResponse.ProtoReflect.Descriptor instead.
func (*AppendResponse) Descriptor() ([]byte, []int) {
	return file_ingest_v1_ingest_proto_rawDescGZIP(), []int{3}
}

func (x *AppendResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *AppendResponse) GetErrorCode() ErrorCode {
	if x != nil {
		return x.ErrorCode
	}
	return ErrorCode_ERROR_CODE_UNSPECIFIED
}

func (x *AppendResponse) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *AppendResponse) GetCommittedLsn() uint64 {
	if x != nil {
		return x.CommittedLsn
	}
	return 0
}

func (x *AppendResponse) GetIngestedCount() uint32 {
	if x != nil {
		return x.IngestedCount
	}
	return 0
}

func (x *AppendResponse) GetRetryAfterMs() uint32 {
	if x != nil {
		return x.RetryAfterMs
	}
	return 0
}

func (x *AppendResponse) GetCurrentLoadPct() uint32 {
	if x != nil {
		return x.CurrentLoadPct
	}
	return 0
}

func (x *AppendResponse) GetLeaderAddress() string {
	if x != nil {
		return x.LeaderAddress
	}
	return ""
}

// GetStatusRequest for health/status checks.
type GetStatusRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetStatusRequest) Reset() {
	*x = GetStatusRequest{}
	mi := &file_ingest_v1_ingest_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStatusRequest) ProtoMessage() {}

func (x *GetStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ingest_v1_ingest_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStatusRequest.ProtoReflect.Descriptor instead.
func (*GetStatusRequest) Descriptor() ([]byte, []int) {
	return file_ingest_v1_ingest_proto_rawDescGZIP(), []int{4}
}

// GetStatusResponse returns ingestor status.
type GetStatusResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Node identifier.
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// Shard this ingestor handles.
	ShardId string `protobuf:"bytes,2,opt,name=shard_id,json=shardId,proto3" json:"shard_id,omitempty"`
	// Whether this node is the Raft leader.
	IsLeader bool `protobuf:"varint,3,opt,name=is_leader,json=isLeader,proto3" json:"is_leader,omitempty"`
	// Current leader address (if known).
	LeaderAddress string `protobuf:"bytes,4,opt,name=leader_address,json=leaderAddress,proto3" json:"leader_address,omitempty"`
	// Raft term.
	RaftTerm uint64 `protobuf:"varint,5,opt,name=raft_term,json=raftTerm,proto3" json:"raft_term,omitempty"`
	// Last applied Raft index.
	LastAppliedIndex uint64 `protobuf:"varint,6,opt,name=last_applied_index,json=lastAppliedIndex,proto3" json:"last_applied_index,omitempty"`
	// Active segment info.
	ActiveSegmentId      uint32 `protobuf:"varint,7,opt,name=active_segment_id,json=activeSegmentId,proto3" json:"active_segment_id,omitempty"`
	ActiveSegmentBytes   uint64 `protobuf:"varint,8,opt,name=active_segment_bytes,json=activeSegmentBytes,proto3" json:"active_segment_bytes,omitempty"`
	ActiveSegmentEntries uint64 `protobuf:"varint,9,opt,name=active_segment_entries,json=activeSegmentEntries,proto3" json:"active_segment_entries,omitempty"`
	// Pending segments awaiting processing.
	PendingSegments uint32 `protobuf:"varint,10,opt,name=pending_segments,json=pendingSegments,proto3" json:"pending_segments,omitempty"`
	// Node health status.
	Health        HealthStatus `protobuf:"varint,11,opt,name=health,proto3,enum=ingest.v1.HealthStatus" json:"health,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetStatusResponse) Reset() {
	*x = GetStatusResponse{}
	mi := &file_ingest_v1_ingest_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStatusResponse) ProtoMessage() {}

func (x *GetStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ingest_v1_ingest_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStatusResponse.ProtoReflect.Descriptor instead.
func (*GetStatusResponse) Descriptor() ([]byte, []int) {
	return file_ingest_v1_ingest_proto_rawDescGZIP(), []int{5}
}

func (x *GetStatusResponse) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *GetStatusResponse) GetShardId() string {
	if x != nil {
		return x.ShardId
	}
	return ""
}

func (x *GetStatusResponse) GetIsLeader() bool {
	if x != nil {
		return x.IsLeader
	}
	return false
}

func (x *GetStatusResponse) GetLeaderAddress() string {
	if x != nil {
		return x.LeaderAddress
	}
	return ""
}

func (x *GetStatusResponse) GetRaftTerm() uint64 {
	if x != nil {
		return x.RaftTerm
	}
	return 0
}

func (x *GetStatusResponse) GetLastAppliedIndex() uint64 {
	if x != nil {
		return x.LastAppliedIndex
	}
	return 0
}

func (x *GetStatusResponse) GetActiveSegmentId() uint32 {
	if x != nil {
		return x.ActiveSegmentId
	}
	return 0
}

func (x *GetStatusResponse) GetActiveSegmentBytes() uint64 {
	if x != nil {
		return x.ActiveSegmentBytes
	}
	return 0
}

func (x *GetStatusResponse) GetActiveSegmentEntries() uint64 {
	if x != nil {
		return x.ActiveSegmentEntries
	}
	return 0
}

func (x *GetStatusResponse) GetPendingSegments() uint32 {
	if x != nil {
		return x.PendingSegments
	}
	return 0
}

func (x *GetStatusResponse) GetHealth() HealthStatus {
	if x != nil {
		return x.Health
	}
	return HealthStatus_HEALTH_STATUS_UNSPECIFIED
}

// GetLeaderRequest for leader discovery.
type GetLeaderRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetLeaderRequest) Reset() {
	*x = GetLeaderRequest{}
	mi := &file_ingest_v1_ingest_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetLeaderRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetLeaderRequest) ProtoMessage() {}

func (x *GetLeaderRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ingest_v1_ingest_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetLeaderRequest.ProtoReflect.Descriptor instead.
func (*GetLeaderRequest) Descriptor() ([]byte, []int) {
	return file_ingest_v1_ingest_proto_rawDescGZIP(), []int{6}
}

// GetLeaderResponse returns the current leader.
type GetLeaderResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Leader node ID.
	LeaderId string `protobuf:"bytes,1,opt,name=leader_id,json=leaderId,proto3" json:"leader_id,omitempty"`
	// Leader gRPC address for client redirect.
	LeaderAddress string `protobuf:"bytes,2,opt,name=leader_address,json=leaderAddress,proto3" json:"leader_address,omitempty"`
	// Whether this node is the leader.
	IsSelf        bool `protobuf:"varint,3,opt,name=is_self,json=isSelf,proto3" json:"is_self,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetLeaderResponse) Reset() {
	*x = GetLeaderResponse{}
	mi := &file_ingest_v1_ingest_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetLeaderResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetLeaderResponse) ProtoMessage() {}

func (x *GetLeaderResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ingest_v1_ingest_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetLeaderResponse.ProtoReflect.Descriptor instead.
func (*GetLeaderResponse) Descriptor() ([]byte, []int) {
	return file_ingest_v1_ingest_proto_rawDescGZIP(), []int{7}
}

func (x *GetLeaderResponse) GetLeaderId() string {
	if x != nil {
		return x.LeaderId
	}
	return ""
}

func (x *GetLeaderResponse) GetLeaderAddress() string {
	if x != nil {
		return x.LeaderAddress
	}
	return ""
}

func (x *GetLeaderResponse) GetIsSelf() bool {
	if x != nil {
		return x.IsSelf
	}
	return false
}

var File_ingest_v1_ingest_proto protoreflect.FileDescriptor

const file_ingest_v1_ingest_proto_rawDesc = "" +
	"\n" +
	"\x16ingest/v1/ingest.proto\x12\tingest.v1\x1a\x1cgoogle/api/annotations.proto\x1a\x1fgoogle/api/field_behavior.proto\x1a.protoc-gen-openapiv2/options/annotations.proto\"2\n" +
	"\bKeyValue\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value\"\x97\x02\n" +
	"\x05Event\x12\x1e\n" +
	"\bevent_id\x18\x01 \x01(\fB\x03\xe0A\x02R\aeventId\x12\"\n" +
	"\n" +
	"event_type\x18\x02 \x01(\tB\x03\xe0A\x02R\teventType\x12\x1f\n" +
	"\voccurred_at\x18\x03 \x01(\x04R\n" +
	"occurredAt\x12\x1d\n" +
	"\apayload\x18\x04 \x01(\fB\x03\xe0A\x02R\apayload\x12<\n" +
	"\vcompression\x18\x05 \x01(\x0e2\x1a.ingest.v1.CompressionTypeR\vcompression\x12\x1b\n" +
	"\tschema_id\x18\x06 \x01(\rR\bschemaId\x12/\n" +
	"\bmetadata\x18\a \x03(\v2\x13.ingest.v1.KeyValueR\bmetadata\"~\n" +
	"\rAppendRequest\x12-\n" +
	"\x06events\x18\x01 \x03(\v2\x10.ingest.v1.EventB\x03\xe0A\x02R\x06events\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x02 \x01(\rR\ttimeoutMs\x12\x1f\n" +
	"\vrouting_key\x18\x03 \x01(\tR\n" +
	"routingKey\"\xc7\x02\n" +
	"\x0eAppendResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x123\n" +
	"\n" +
	"error_code\x18\x02 \x01(\x0e2\x14.ingest.v1.ErrorCodeR\terrorCode\x12#\n" +
	"\rerror_message\x18\x03 \x01(\tR\ferrorMessage\x12#\n" +
	"\rcommitted_lsn\x18\x04 \x01(\x04R\fcommittedLsn\x12%\n" +
	"\x0eingested_count\x18\x05 \x01(\rR\ringestedCount\x12$\n" +
	"\x0eretry_after_ms\x18\x06 \x01(\rR\fretryAfterMs\x12(\n" +
	"\x10current_load_pct\x18\a \x01(\rR\x0ecurrentLoadPct\x12%\n" +
	"\x0eleader_address\x18\b \x01(\tR\rleaderAddress\"\x12\n" +
	"\x10GetStatusRequest\"\xc6\x03\n" +
	"\x11GetStatusResponse\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\tR\x06nodeId\x12\x19\n" +
	"\bshard_id\x18\x02 \x01(\tR\ashardId\x12\x1b\n" +
	"\tis_leader\x18\x03 \x01(\bR\bisLeader\x12%\n" +
	"\x0eleader_address\x18\x04 \x01(\tR\rleaderAddress\x12\x1b\n" +
	"\traft_term\x18\x05 \x01(\x04R\braftTerm\x12,\n" +
	"\x12last_applied_index\x18\x06 \x01(\x04R\x10lastAppliedIndex\x12*\n" +
	"\x11active_segment_id\x18\a \x01(\rR\x0factiveSegmentId\x120\n" +
	"\x14active_segment_bytes\x18\b \x01(\x04R\x12activeSegmentBytes\x124\n" +
	"\x16active_segment_entries\x18\t \x01(\x04R\x14activeSegmentEntries\x12)\n" +
	"\x10pending_segments\x18\n" +
	" \x01(\rR\x0fpendingSegments\x12/\n" +
	"\x06health\x18\v \x01(\x0e2\x17.ingest.v1.HealthStatusR\x06health\"\x12\n" +
	"\x10GetLeaderRequest\"p\n" +
	"\x11GetLeaderResponse\x12\x1b\n" +
	"\tleader_id\x18\x01 \x01(\tR\bleaderId\x12%\n" +
	"\x0eleader_address\x18\x02 \x01(\tR\rleaderAddress\x12\x17\n" +
	"\ais_self\x18\x03 \x01(\bR\x06isSelf*\x86\x01\n" +
	"\x0fCompressionType\x12 \n" +
	"\x1cCOMPRESSION_TYPE_UNSPECIFIED\x10\x00\x12\x19\n" +
	"\x15COMPRESSION_TYPE_NONE\x10\x01\x12\x1b\n" +
	"\x17COMPRESSION_TYPE_SNAPPY\x10\x02\x12\x19\n" +
	"\x15COMPRESSION_TYPE_ZSTD\x10\x03*\xfe\x02\n" +
	"\tErrorCode\x12\x1a\n" +
	"\x16ERROR_CODE_UNSPECIFIED\x10\x00\x12\x11\n" +
	"\rERROR_CODE_OK\x10\x01\x12\x1e\n" +
	"\x1aERROR_CODE_INVALID_REQUEST\x10\x02\x12 \n" +
	"\x1cERROR_CODE_INVALID_NAMESPACE\x10\x03\x12\x1c\n" +
	"\x18ERROR_CODE_INVALID_TOPIC\x10\x04\x12\x1c\n" +
	"\x18ERROR_CODE_INVALID_EVENT\x10\x05\x12 \n" +
	"\x1cERROR_CODE_PAYLOAD_TOO_LARGE\x10\x06\x12\x1b\n" +
	"\x17ERROR_CODE_RATE_LIMITED\x10\a\x12\x19\n" +
	"\x15ERROR_CODE_NOT_LEADER\x10\b\x12\x18\n" +
	"\x14ERROR_CODE_NO_QUORUM\x10\t\x12\x16\n" +
	"\x12ERROR_CODE_TIMEOUT\x10\n" +
	"\x12\x1f\n" +
	"\x1bERROR_CODE_SCHEMA_NOT_FOUND\x10\v\x12\x17\n" +
	"\x13ERROR_CODE_INTERNAL\x10c*\x81\x01\n" +
	"\fHealthStatus\x12\x1d\n" +
	"\x19HEALTH_STATUS_UNSPECIFIED\x10\x00\x12\x19\n" +
	"\x15HEALTH_STATUS_HEALTHY\x10\x01\x12\x1a\n" +
	"\x16HEALTH_STATUS_DEGRADED\x10\x02\x12\x1b\n" +
	"\x17HEALTH_STATUS_UNHEALTHY\x10\x032\xfa\x04\n" +
	"\rIngestService\x12\xba\x01\n" +
	"\x06Append\x12\x18.ingest.v1.AppendRequest\x1a\x19.ingest.v1.AppendResponse\"{\x92Ac\n" +
	"\x06Ingest\x12\rIngest events\x1aJAppend a batch of events. Set x-namespace and x-topic headers for routing.\x82\xd3\xe4\x93\x02\x0f:\x01*\"\n" +
	"/v1/events\x12G\n" +
	"\fAppendStream\x12\x18.ingest.v1.AppendRequest\x1a\x19.ingest.v1.AppendResponse(\x010\x01\x12\xb0\x01\n" +
	"\tGetStatus\x12\x1b.ingest.v1.GetStatusRequest\x1a\x1c.ingest.v1.GetStatusResponse\"h\x92AS\n" +
	"\x06Status\x12\x13Get ingestor status\x1a4Returns health, leader info, and segment statistics.\x82\xd3\xe4\x93\x02\f\x12\n" +
	"/v1/status\x12\xaf\x01\n" +
	"\tGetLeader\x12\x1b.ingest.v1.GetLeaderRequest\x1a\x1c.ingest.v1.GetLeaderResponse\"g\x92AR\n" +
	"\x06Status\x12\x12Get current leader\x1a4Returns the Raft leader address for client redirect.\x82\xd3\xe4\x93\x02\f\x12\n" +
	"/v1/leaderB\xc0\x02\x92A\x9b\x01\x12r\n" +
	"\x12Unijord Ingest API\x128Lakehouse-native event streaming. Events in, tables out.\"\x1d\n" +
	"\aUnijord\x12\x12https://unijord.io2\x031.0*\x01\x022\x10application/json:\x10application/json\n" +
	"\rcom.ingest.v1B\vIngestProtoP\x01Z>github.com/unijord/unijord/pkg/gen/go/proto/ingest/v1;ingestv1\xa2\x02\x03IXX\xaa\x02\tIngest.V1\xca\x02\tIngest\\V1\xe2\x02\x15Ingest\\V1\\GPBMetadata\xea\x02\n" +
	"Ingest::V1b\x06proto3"

var (
	file_ingest_v1_ingest_proto_rawDescOnce sync.Once
	file_ingest_v1_ingest_proto_rawDescData []byte
)

func file_ingest_v1_ingest_proto_rawDescGZIP() []byte {
	file_ingest_v1_ingest_proto_rawDescOnce.Do(func() {
		file_ingest_v1_ingest_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_ingest_v1_ingest_proto_rawDesc), len(file_ingest_v1_ingest_proto_rawDesc)))
	})
	return file_ingest_v1_ingest_proto_rawDescData
}

var file_ingest_v1_ingest_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_ingest_v1_ingest_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_ingest_v1_ingest_proto_goTypes = []any{
	(CompressionType)(0),      // 0: ingest.v1.CompressionType
	(ErrorCode)(0),            // 1: ingest.v1.ErrorCode
	(HealthStatus)(0),         // 2: ingest.v1.HealthStatus
	(*KeyValue)(nil),          // 3: ingest.v1.KeyValue
	(*Event)(nil),             // 4: ingest.v1.Event
	(*AppendRequest)(nil),     // 5: ingest.v1.AppendRequest
	(*AppendResponse)(nil),    // 6: ingest.v1.AppendResponse
	(*GetStatusRequest)(nil),  // 7: ingest.v1.GetStatusRequest
	(*GetStatusResponse)(nil), // 8: ingest.v1.GetStatusResponse
	(*GetLeaderRequest)(nil),  // 9: ingest.v1.GetLeaderRequest
	(*GetLeaderResponse)(nil), // 10: ingest.v1.GetLeaderResponse
}
var file_ingest_v1_ingest_proto_depIdxs = []int32{
	0,  // 0: ingest.v1.Event.compression:type_name -> ingest.v1.CompressionType
	3,  // 1: ingest.v1.Event.metadata:type_name -> ingest.v1.KeyValue
	4,  // 2: ingest.v1.AppendRequest.events:type_name -> ingest.v1.Event
	1,  // 3: ingest.v1.AppendResponse.error_code:type_name -> ingest.v1.ErrorCode
	2,  // 4: ingest.v1.GetStatusResponse.health:type_name -> ingest.v1.HealthStatus
	5,  // 5: ingest.v1.IngestService.Append:input_type -> ingest.v1.AppendRequest
	5,  // 6: ingest.v1.IngestService.AppendStream:input_type -> ingest.v1.AppendRequest
	7,  // 7: ingest.v1.IngestService.GetStatus:input_type -> ingest.v1.GetStatusRequest
	9,  // 8: ingest.v1.IngestService.GetLeader:input_type -> ingest.v1.GetLeaderRequest
	6,  // 9: ingest.v1.IngestService.Append:output_type -> ingest.v1.AppendResponse
	6,  // 10: ingest.v1.IngestService.AppendStream:output_type -> ingest.v1.AppendResponse
	8,  // 11: ingest.v1.IngestService.GetStatus:output_type -> ingest.v1.GetStatusResponse
	10, // 12: ingest.v1.IngestService.GetLeader:output_type -> ingest.v1.GetLeaderResponse
	9,  // [9:13] is the sub-list for method output_type
	5,  // [5:9] is the sub-list for method input_type
	5,  // [5:5] is the sub-list for extension type_name
	5,  // [5:5] is the sub-list for extension extendee
	0,  // [0:5] is the sub-list for field type_name
}

func init() { file_ingest_v1_ingest_proto_init() }
func file_ingest_v1_ingest_proto_init() {
	if File_ingest_v1_ingest_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_ingest_v1_ingest_proto_rawDesc), len(file_ingest_v1_ingest_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   8,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_ingest_v1_ingest_proto_goTypes,
		DependencyIndexes: file_ingest_v1_ingest_proto_depIdxs,
		EnumInfos:         file_ingest_v1_ingest_proto_enumTypes,
		MessageInfos:      file_ingest_v1_ingest_proto_msgTypes,
	}.Build()
	File_ingest_v1_ingest_proto = out.File
	file_ingest_v1_ingest_proto_goTypes = nil
	file_ingest_v1_ingest_proto_depIdxs = nil
}
